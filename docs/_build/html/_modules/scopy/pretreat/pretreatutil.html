
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>scopy.pretreat.pretreatutil &#8212; Scopy 1.1.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/./cssbasic.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Scopy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/Scopy.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scopy.pretreat.pretreatutil</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Mon Sep  9 10:41:15 2019</span>

<span class="sd">This module is derived from molvs(https://github.com/mcs07/MolVS.git)</span>

<span class="sd">@Author: Zhi-Jiang Yang, Dong-Sheng Cao</span>
<span class="sd">@Institution: CBDD Group, Xiangya School of Pharmaceutical Science, CSU, Chinaï¼Œ</span>
<span class="sd">@Homepage: http://www.scbdd.com</span>
<span class="sd">@Mail: yzjkid9@gmail.com; oriental-cds@163.com</span>
<span class="sd">@Blog: https://blog.moyule.me</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">tee</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">rdMolDescriptors</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem.rdchem</span> <span class="k">import</span> <span class="n">BondDir</span><span class="p">,</span> <span class="n">BondStereo</span><span class="p">,</span> <span class="n">BondType</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="c1">#==============================================================================</span>
<span class="c1"># from .utils import memoized_property</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="memoized_property"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.memoized_property">[docs]</a><span class="k">def</span> <span class="nf">memoized_property</span><span class="p">(</span><span class="n">fget</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to create memoized properties.&quot;&quot;&quot;</span>
    <span class="n">attr_name</span> <span class="o">=</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fget</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fget</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fget_memoized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget_memoized</span><span class="p">)</span></div>


<div class="viewcode-block" id="pairwise"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.pairwise">[docs]</a><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utility function to iterate in a pairwise fashion.&quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>
<span class="c1">#==============================================================================</span>
<span class="c1"># from .metal import MetalDisconnector</span>
<span class="c1">#==============================================================================</span>
<span class="c1"># TODO: This won&#39;t disconnect e.g. covalent [Na]Cl...</span>
<div class="viewcode-block" id="MetalDisconnector"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.MetalDisconnector">[docs]</a><span class="k">class</span> <span class="nc">MetalDisconnector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for breaking covalent bonds between metals and organic atoms under certain conditions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing MetalDisconnector&#39;</span><span class="p">)</span>
        <span class="c1"># Initialize SMARTS to identify relevant substructures</span>
        <span class="c1"># TODO: Use atomic numbers instead of element symbols in SMARTS to allow for isotopes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metal_nof</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[Li,Na,K,Rb,Cs,Fr,Be,Mg,Ca,Sr,Ba,Ra,Sc,Ti,V,Cr,Mn,Fe,Co,Ni,Cu,Zn,Al,Ga,Y,Zr,Nb,Mo,Tc,Ru,Rh,Pd,Ag,Cd,In,Sn,Hf,Ta,W,Re,Os,Ir,Pt,Au,Hg,Tl,Pb,Bi]~[N,O,F]&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metal_non</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[Al,Sc,Ti,V,Cr,Mn,Fe,Co,Ni,Cu,Zn,Y,Zr,Nb,Mo,Tc,Ru,Rh,Pd,Ag,Cd,Hf,Ta,W,Re,Os,Ir,Pt,Au]~[B,C,Si,P,As,Sb,S,Se,Te,Cl,Br,I,At]&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a MetalDisconnector instance like a function is the same as calling its disconnect(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="MetalDisconnector.disconnect"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.MetalDisconnector.disconnect">[docs]</a>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Break covalent bonds between metals and organic atoms under certain conditions.</span>

<span class="sd">        The algorithm works as follows:</span>

<span class="sd">        - Disconnect N, O, F from any metal.</span>
<span class="sd">        - Disconnect other non-metals from transition metals + Al (but not Hg, Ga, Ge, In, Sn, As, Tl, Pb, Bi, Po).</span>
<span class="sd">        - For every bond broken, adjust the charges of the begin and end atoms accordingly.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The molecule with metals disconnected.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running MetalDisconnector&#39;</span><span class="p">)</span>
        <span class="c1"># Remove bonds that match SMARTS</span>
        <span class="k">for</span> <span class="n">smarts</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_metal_nof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metal_non</span><span class="p">]:</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>
            <span class="n">rwmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="c1"># TODO: Could get the valence contributions of the bond instead of GetBondTypeAsDouble?</span>
                <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondTypeAsDouble</span><span class="p">()))</span>
                <span class="n">rwmol</span><span class="o">.</span><span class="n">RemoveBond</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="c1"># Adjust neighbouring charges accordingly</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">rwmol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">chg</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">atom1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">atom1</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">+</span> <span class="n">chg</span><span class="p">)</span>
                <span class="n">atom2</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">atom2</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom2</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">-</span> <span class="n">chg</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removed covalent bond between </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">atom1</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">(),</span> <span class="n">atom2</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">())</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div></div>
<span class="c1">#==============================================================================</span>
<span class="c1">#from .fragment import PREFER_ORGANIC, LargestFragmentChooser, FragmentRemover</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="FragmentPattern"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.FragmentPattern">[docs]</a><span class="k">class</span> <span class="nc">FragmentPattern</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A fragment defined by a SMARTS pattern.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a FragmentPattern with a name and a SMARTS pattern.</span>

<span class="sd">        :param name: A name for this FragmentPattern.</span>
<span class="sd">        :param smarts: A SMARTS pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span> <span class="o">=</span> <span class="n">smarts</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">smarts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;FragmentPattern(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="c1">#: The default list of :class:`FragmentPatterns &lt;molvs.fragment.FragmentPattern&gt;` to be used by</span>
<span class="c1">#: :class:`~molvs.fragment.FragmentRemover`.</span>
<span class="n">REMOVE_FRAGMENTS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;hydrogen&#39;</span><span class="p">,</span> <span class="s1">&#39;[H]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;fluorine&#39;</span><span class="p">,</span> <span class="s1">&#39;[F]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;chlorine&#39;</span><span class="p">,</span> <span class="s1">&#39;[Cl]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;bromine&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;iodine&#39;</span><span class="p">,</span> <span class="s1">&#39;[I]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;lithium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Li]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;sodium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Na]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;potassium&#39;</span><span class="p">,</span> <span class="s1">&#39;[K]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;calcium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Ca]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;magnesium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Mg]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;aluminium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Al]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;barium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Ba]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;bismuth&#39;</span><span class="p">,</span> <span class="s1">&#39;[Bi]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;silver&#39;</span><span class="p">,</span> <span class="s1">&#39;[Ag]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;strontium&#39;</span><span class="p">,</span> <span class="s1">&#39;[Sr]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;zinc&#39;</span><span class="p">,</span> <span class="s1">&#39;[Zn]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;ammonia/ammonium&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;water/hydroxide&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;methyl amine&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#7]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;sulfide&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;nitrate&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7](=[#8])(-[#8])-[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;phosphate&#39;</span><span class="p">,</span> <span class="s1">&#39;[P](=[#8])(-[#8])(-[#8])-[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;hexafluorophosphate&#39;</span><span class="p">,</span> <span class="s1">&#39;[P](-[#9])(-[#9])(-[#9])(-[#9])(-[#9])-[#9]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;sulfate&#39;</span><span class="p">,</span> <span class="s1">&#39;[S](=[#8])(=[#8])(-[#8])-[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;methyl sulfonate&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[S](=[#8])(=[#8])(-[#8])&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;trifluoromethanesulfonic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[S](=[#8])(=[#8])-[#6](-[#9])(-[#9])-[#9]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;trifluoroacetic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;[#9]-[#6](-[#9])(-[#9])-[#6](=[#8])-[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;1,2-dichloroethane&#39;</span><span class="p">,</span> <span class="s1">&#39;[Cl]-[#6]-[#6]-[Cl]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;1,2-dimethoxyethane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#8]-[#6]-[#6]-[#8]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;1,4-dioxane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-1-[#6]-[#8]-[#6]-[#6]-[#8]-1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;1-methyl-2-pyrrolidinone&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#7]-1-[#6]-[#6]-[#6]-[#6]-1=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;2-butanone&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#6](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;acetate/acetic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;acetone&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;acetonitrile&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]#[N]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;benzene&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]1[#6][#6][#6][#6][#6]1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;butanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6]-[#6]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;t-butanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6](-[#6])(-[#6])-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;chloroform&#39;</span><span class="p">,</span> <span class="s1">&#39;[Cl]-[#6](-[Cl])-[Cl]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;cycloheptane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-1-[#6]-[#6]-[#6]-[#6]-[#6]-[#6]-1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;cyclohexane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-1-[#6]-[#6]-[#6]-[#6]-[#6]-1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;dichloromethane&#39;</span><span class="p">,</span> <span class="s1">&#39;[Cl]-[#6]-[Cl]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;diethyl ether&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#8]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;diisopropyl ether&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6](-[#6])-[#8]-[#6](-[#6])-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;dimethyl formamide&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#7](-[#6])-[#6]=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;dimethyl sulfoxide&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[S](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;ethanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;ethyl acetate&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#8]-[#6](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;formic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6]=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;heptane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#6]-[#6]-[#6]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;hexane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#6]-[#6]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;isopropanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6](-[#6])-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;methanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;N,N-dimethylacetamide&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#7](-[#6])-[#6](-[#6])=[#8]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;pentane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]-[#6]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;propanol&#39;</span><span class="p">,</span> <span class="s1">&#39;[#8]-[#6]-[#6]-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;pyridine&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-1=[#6]-[#6]=[#7]-[#6]=[#6]-1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;t-butyl methyl ether&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#8]-[#6](-[#6])(-[#6])-[#6]&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;tetrahydrofurane&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-1-[#6]-[#6]-[#8]-[#6]-1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;toluene&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]~1~[#6]~[#6]~[#6]~[#6]~[#6]~1&#39;</span><span class="p">),</span>
    <span class="n">FragmentPattern</span><span class="p">(</span><span class="s1">&#39;xylene&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]-[#6]~1~[#6](-[#6])~[#6]~[#6]~[#6]~[#6]~1&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">#: The default value for whether to ensure at least one fragment is left after FragmentRemover is applied.</span>
<span class="n">LEAVE_LAST</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1">#: The default value for whether LargestFragmentChooser sees organic fragments as &quot;larger&quot; than inorganic fragments.</span>
<span class="n">PREFER_ORGANIC</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="is_organic"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.is_organic">[docs]</a><span class="k">def</span> <span class="nf">is_organic</span><span class="p">(</span><span class="n">fragment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if fragment contains at least one carbon atom.</span>

<span class="sd">    :param fragment: The fragment as an RDKit Mol object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Consider a different definition?</span>
    <span class="c1"># Could allow only H, C, N, O, S, P, F, Cl, Br, I</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fragment</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="FragmentRemover"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.FragmentRemover">[docs]</a><span class="k">class</span> <span class="nc">FragmentRemover</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for filtering out fragments using SMARTS patterns.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragments</span><span class="o">=</span><span class="n">REMOVE_FRAGMENTS</span><span class="p">,</span> <span class="n">leave_last</span><span class="o">=</span><span class="n">LEAVE_LAST</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a FragmentRemover with an optional custom list of :class:`~molvs.fragment.FragmentPattern`.</span>

<span class="sd">        Setting leave_last to True will ensure at least one fragment is left in the molecule, even if it is matched by a</span>
<span class="sd">        :class:`~molvs.fragment.FragmentPattern`. Fragments are removed in the order specified in the list, so place</span>
<span class="sd">        those you would prefer to be left towards the end of the list. If all the remaining fragments match the same</span>
<span class="sd">        :class:`~molvs.fragment.FragmentPattern`, they will all be left.</span>

<span class="sd">        :param fragments: A list of :class:`~molvs.fragment.FragmentPattern` to remove.</span>
<span class="sd">        :param bool leave_last: Whether to ensure at least one fragment is left.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing FragmentRemover&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leave_last</span> <span class="o">=</span> <span class="n">leave_last</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a FragmentRemover instance like a function is the same as calling its remove(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="FragmentRemover.remove"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.FragmentRemover.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the molecule with specified fragments removed.</span>

<span class="sd">        :param mol: The molecule to remove fragments from.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The molecule with fragments removed.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running FragmentRemover&#39;</span><span class="p">)</span>
        <span class="c1"># Iterate FragmentPatterns and remove matching fragments</span>
        <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="c1"># If nothing is left or leave_last and only one fragment, end here</span>
            <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leave_last</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="c1"># Apply removal for this FragmentPattern</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">DeleteSubstructs</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">frag</span><span class="o">.</span><span class="n">smarts</span><span class="p">,</span> <span class="n">onlyFrags</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">==</span> <span class="n">removed</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">():</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removed fragment: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">frag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leave_last</span> <span class="ow">and</span> <span class="n">removed</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># All the remaining fragments match this pattern - leave them all</span>
                <span class="k">break</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">removed</span>
        <span class="k">return</span> <span class="n">mol</span></div></div>


<div class="viewcode-block" id="LargestFragmentChooser"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LargestFragmentChooser">[docs]</a><span class="k">class</span> <span class="nc">LargestFragmentChooser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for selecting the largest covalent unit in a molecule with multiple fragments.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefer_organic</span><span class="o">=</span><span class="n">PREFER_ORGANIC</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        If prefer_organic is set to True, any organic fragment will be considered larger than any inorganic fragment. A</span>
<span class="sd">        fragment is considered organic if it contains a carbon atom.</span>

<span class="sd">        :param bool prefer_organic: Whether to prioritize organic fragments above all others.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing LargestFragmentChooser&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefer_organic</span> <span class="o">=</span> <span class="n">prefer_organic</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a LargestFragmentChooser instance like a function is the same as calling its choose(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="LargestFragmentChooser.choose"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LargestFragmentChooser.choose">[docs]</a>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the largest covalent unit.</span>

<span class="sd">        The largest fragment is determined by number of atoms (including hydrogens). Ties are broken by taking the</span>
<span class="sd">        fragment with the higher molecular weight, and then by taking the first alphabetically by SMILES if needed.</span>

<span class="sd">        :param mol: The molecule to choose the largest fragment from.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The largest fragment.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running LargestFragmentChooser&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: Alternatively allow a list of fragments to be passed as the mol parameter</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">asMols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Fragment: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span>
            <span class="n">organic</span> <span class="o">=</span> <span class="n">is_organic</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefer_organic</span><span class="p">:</span>
                <span class="c1"># Skip this fragment if not organic and we already have an organic fragment as the largest so far</span>
                <span class="k">if</span> <span class="n">largest</span> <span class="ow">and</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;organic&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">organic</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Reset largest if it wasn&#39;t organic and this fragment is organic</span>
                <span class="k">if</span> <span class="n">largest</span> <span class="ow">and</span> <span class="n">organic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;organic&#39;</span><span class="p">]:</span>
                    <span class="n">largest</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Count atoms</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                <span class="n">atoms</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span>
            <span class="c1"># Skip this fragment if fewer atoms than the largest</span>
            <span class="k">if</span> <span class="n">largest</span> <span class="ow">and</span> <span class="n">atoms</span> <span class="o">&lt;</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Skip this fragment if equal number of atoms but weight is lower</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">rdMolDescriptors</span><span class="o">.</span><span class="n">CalcExactMolWt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">largest</span> <span class="ow">and</span> <span class="n">atoms</span> <span class="o">==</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Skip this fragment if equal atoms and equal weight but smiles comes last alphabetically</span>
            <span class="k">if</span> <span class="n">largest</span> <span class="ow">and</span> <span class="n">atoms</span> <span class="o">==</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">weight</span> <span class="o">==</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">smiles</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;smiles&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Otherwise this is the largest so far</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New largest fragment: </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;smiles&#39;</span><span class="p">:</span> <span class="n">smiles</span><span class="p">,</span> <span class="s1">&#39;fragment&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;atoms&#39;</span><span class="p">:</span> <span class="n">atoms</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weight</span><span class="p">,</span> <span class="s1">&#39;organic&#39;</span><span class="p">:</span> <span class="n">organic</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">largest</span><span class="p">[</span><span class="s1">&#39;fragment&#39;</span><span class="p">]</span></div></div>

<span class="c1">#==============================================================================</span>
<span class="c1">#from .normalize import NORMALIZATIONS, MAX_RESTARTS, Normalizer</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="Normalization"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Normalization">[docs]</a><span class="k">class</span> <span class="nc">Normalization</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A normalization transform defined by reaction SMARTS.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param string name: A name for this Normalization</span>
<span class="sd">        :param string transform: Reaction SMARTS to define the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing Normalization: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_str</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading Normalization transform: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_str</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Normalization(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="c1">#: The default list of Normalization transforms.</span>
<span class="n">NORMALIZATIONS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="c1"># Opposite of #2.1 in InChI technical manual? Covered by RDKit Sanitization.</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Nitro to N+(O-)=O&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,P,As,Sb;X3:1](=[O,S,Se,Te:2])=[O,S,Se,Te:3]&gt;&gt;[*+1:1]([*-1:2])=[*:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Sulfone to S(=O)(=O)&#39;</span><span class="p">,</span> <span class="s1">&#39;[S+2:1]([O-:2])([O-:3])&gt;&gt;[S+0:1](=[O-0:2])(=[O-0:3])&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Pyridine oxide to n+O-&#39;</span><span class="p">,</span> <span class="s1">&#39;[n:1]=[O:2]&gt;&gt;[n+:1][O-:2]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Azide to N=N+=N-&#39;</span><span class="p">,</span> <span class="s1">&#39;[*,H:1][N:2]=[N:3]#[N:4]&gt;&gt;[*,H:1][N:2]=[N+:3]=[N-:4]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Diazo/azo to =N+=N-&#39;</span><span class="p">,</span> <span class="s1">&#39;[*:1]=[N:2]#[N:3]&gt;&gt;[*:1]=[N+:2]=[N-:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Sulfoxide to -S+(O-)-&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O:1][S+0;X3:2](=[O:3])[!O:4]&gt;&gt;[*:1][S+1:2]([O-:3])[*:4]&#39;</span><span class="p">),</span>
    <span class="c1"># Equivalent to #1.5 in InChI technical manual</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Phosphate to P(O-)=O&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,S,Se,Te;-1:1][P+;D4:2][O,S,Se,Te;-1:3]&gt;&gt;[*+0:1]=[P+0;D5:2][*-1:3]&#39;</span><span class="p">),</span>
    <span class="c1"># Equivalent to #1.8 in InChI technical manual</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;C/S+N to C/S=N+&#39;</span><span class="p">,</span> <span class="s1">&#39;[C,S;X3+1:1]([NX3:2])[NX3!H0:3]&gt;&gt;[*+0:1]([N:2])=[N+:3]&#39;</span><span class="p">),</span>
    <span class="c1"># Equivalent to #1.8 in InChI technical manual</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;P+N to P=N+&#39;</span><span class="p">,</span> <span class="s1">&#39;[P;X4+1:1]([NX3:2])[NX3!H0:3]&gt;&gt;[*+0:1]([N:2])=[N+:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Normalize hydrazine-diazonium&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4:1][NX3H:2]-[NX3H:3][CX4:4][NX2+:5]#[NX1:6]&gt;&gt;[CX4:1][NH0:2]=[NH+:3][C:4][N+0:5]=[NH:6]&#39;</span><span class="p">),</span>
    <span class="c1"># Equivalent to #1.3 in InChI technical manual</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,3-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,P,As,Sb,O,S,Se,Te;-1:1]-[A+0:2]=[N,P,As,Sb,O,S,Se,Te;+1:3]&gt;&gt;[*-0:1]=[*:2]-[*+0:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,3-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[n,o,p,s;-1:1]:[a:2]=[N,O,P,S;+1:3]&gt;&gt;[*-0:1]:[*:2]-[*+0:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,3-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,O,P,S;-1:1]-[a:2]:[n,o,p,s;+1:3]&gt;&gt;[*-0:1]=[*:2]:[*+0:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,5-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,P,As,Sb,O,S,Se,Te;-1:1]-[A+0:2]=[A:3]-[A:4]=[N,P,As,Sb,O,S,Se,Te;+1:5]&gt;&gt;[*-0:1]=[*:2]-[*:3]=[*:4]-[*+0:5]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,5-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[n,o,p,s;-1:1]:[a:2]:[a:3]:[c:4]=[N,O,P,S;+1:5]&gt;&gt;[*-0:1]:[*:2]:[*:3]:[c:4]-[*+0:5]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Recombine 1,5-separated charges&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,O,P,S;-1:1]-[c:2]:[a:3]:[a:4]:[n,o,p,s;+1:5]&gt;&gt;[*-0:1]=[c:2]:[*:3]:[*:4]:[*+0:5]&#39;</span><span class="p">),</span>
    <span class="c1"># Conjugated cation rules taken from Francis Atkinson&#39;s standardiser. Those that can reduce aromaticity aren&#39;t included</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Normalize 1,3 conjugated cation&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,O;+0!H0:1]-[A:2]=[N!$(*[O-]),O;+1H0:3]&gt;&gt;[*+1:1]=[*:2]-[*+0:3]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Normalize 1,3 conjugated cation&#39;</span><span class="p">,</span> <span class="s1">&#39;[n;+0!H0:1]:[c:2]=[N!$(*[O-]),O;+1H0:3]&gt;&gt;[*+1:1]:[*:2]-[*+0:3]&#39;</span><span class="p">),</span>
    <span class="c1">#Normalization(&#39;Normalize 1,3 conjugated cation&#39;, &#39;[N,O;+0!H0:1]-[c:2]:[n!$(*[O-]),o;+1H0:3]&gt;&gt;[*+1:1]=[*:2]:[*+0:3]&#39;),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Normalize 1,5 conjugated cation&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,O;+0!H0:1]-[A:2]=[A:3]-[A:4]=[N!$(*[O-]),O;+1H0:5]&gt;&gt;[*+1:1]=[*:2]-[*:3]=[*:4]-[*+0:5]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Normalize 1,5 conjugated cation&#39;</span><span class="p">,</span> <span class="s1">&#39;[n;+0!H0:1]:[a:2]:[a:3]:[c:4]=[N!$(*[O-]),O;+1H0:5]&gt;&gt;[n+1:1]:[*:2]:[*:3]:[*:4]-[*+0:5]&#39;</span><span class="p">),</span>
    <span class="c1"># Normalization(&#39;Normalize 1,5 conjugated cation&#39;, &#39;[N,O;+0!H0:1]-[c:2]:[a:3]:[a:4]:[n!$(*[O-]),o;+1H0:5]&gt;&gt;[*+1:1]=[c:2]:[*:3]:[*:4]:[*+0:5]&#39;),</span>
    <span class="c1"># Normalization(&#39;Normalize 1,5 conjugated cation&#39;, &#39;[n;+0!H0:1]1:[a:2]:[a:3]:[a:4]:[n!$(*[O-]);+1H0:5]1&gt;&gt;[n+1:1]1:[*:2]:[*:3]:[*:4]:[n+0:5]1&#39;),</span>
    <span class="c1"># Normalization(&#39;Normalize 1,5 conjugated cation&#39;, &#39;[n;+0!H0:1]:[a:2]:[a:3]:[a:4]:[n!$(*[O-]);+1H0:5]&gt;&gt;[n+1:1]:[*:2]:[*:3]:[*:4]:[n+0:5]&#39;),</span>
    <span class="c1"># Equivalent to #1.6 in InChI technical manual. RDKit Sanitization handles this for perchlorate.</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Charge normalization&#39;</span><span class="p">,</span> <span class="s1">&#39;[F,Cl,Br,I,At;-1:1]=[O:2]&gt;&gt;[*-0:1][O-:2]&#39;</span><span class="p">),</span>
    <span class="n">Normalization</span><span class="p">(</span><span class="s1">&#39;Charge recombination&#39;</span><span class="p">,</span> <span class="s1">&#39;[N,P,As,Sb;-1:1]=[C+;v3:2]&gt;&gt;[*+0:1]#[C+0:2]&#39;</span><span class="p">),</span>
<span class="p">)</span>
<span class="c1"># InChI technical manual has many additional rules that cover situations that are disallowed by RDKit</span>


<span class="c1">#: The default value for the maximum number of times to attempt to apply the series of normalizations.</span>
<span class="n">MAX_RESTARTS</span> <span class="o">=</span> <span class="mi">200</span>


<div class="viewcode-block" id="Normalizer"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Normalizer">[docs]</a><span class="k">class</span> <span class="nc">Normalizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for applying Normalization transforms.</span>

<span class="sd">    This class is typically used to apply a series of Normalization transforms to correct functional groups and</span>
<span class="sd">    recombine charges. Each transform is repeatedly applied until no further changes occur.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalizations</span><span class="o">=</span><span class="n">NORMALIZATIONS</span><span class="p">,</span> <span class="n">max_restarts</span><span class="o">=</span><span class="n">MAX_RESTARTS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Normalizer with an optional custom list of :class:`~molvs.normalize.Normalization` transforms.</span>

<span class="sd">        :param normalizations: A list of  :class:`~molvs.normalize.Normalization` transforms to apply.</span>
<span class="sd">        :param int max_restarts: The maximum number of times to attempt to apply the series of normalizations (default</span>
<span class="sd">                                 200).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing Normalizer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizations</span> <span class="o">=</span> <span class="n">normalizations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_restarts</span> <span class="o">=</span> <span class="n">max_restarts</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a Normalizer instance like a function is the same as calling its normalize(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Normalizer.normalize"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Normalizer.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a series of Normalization transforms to correct functional groups and recombine charges.</span>

<span class="sd">        A series of transforms are applied to the molecule. For each Normalization, the transform is applied repeatedly</span>
<span class="sd">        until no further changes occur. If any changes occurred, we go back and start from the first Normalization</span>
<span class="sd">        again, in case the changes mean an earlier transform is now applicable. The molecule is returned once the entire</span>
<span class="sd">        series of Normalizations cause no further changes or if max_restarts (default 200) is reached.</span>

<span class="sd">        :param mol: The molecule to normalize.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The normalized fragment.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running Normalizer&#39;</span><span class="p">)</span>
        <span class="c1"># Normalize each fragment separately to get around quirky RunReactants behaviour</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">asMols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normalize_fragment</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span>
        <span class="c1"># Join normalized fragments into a single molecule again</span>
        <span class="n">outmol</span> <span class="o">=</span> <span class="n">fragments</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">outmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">outmol</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">outmol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outmol</span></div>

    <span class="k">def</span> <span class="nf">_normalize_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_restarts</span><span class="p">):</span>
            <span class="c1"># Iterate through Normalization transforms and apply each in order</span>
            <span class="k">for</span> <span class="n">normalization</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizations</span><span class="p">:</span>
                <span class="n">product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">normalization</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">product</span><span class="p">:</span>
                    <span class="c1"># If transform changed mol, go back to first rule and apply each again</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Rule applied: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">normalization</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">mol</span> <span class="o">=</span> <span class="n">product</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For loop finishes normally, all applicable transforms have been applied</span>
                <span class="k">return</span> <span class="n">mol</span>
        <span class="c1"># If we&#39;re still going after max_restarts (default 200), stop and warn, but still return the mol</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Gave up normalization after </span><span class="si">%s</span><span class="s1"> restarts&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_restarts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repeatedly apply normalization transform to molecule until no changes occur.</span>

<span class="sd">        It is possible for multiple products to be produced when a rule is applied. The rule is applied repeatedly to</span>
<span class="sd">        each of the products, until no further changes occur or after 20 attempts. If there are multiple unique products</span>
<span class="sd">        after the final application, the first product (sorted alphabetically by SMILES) is chosen.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
            <span class="n">products</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mols</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">mol</span><span class="p">,))]:</span>
                    <span class="k">if</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">catchErrors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">products</span><span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">product</span>
            <span class="k">if</span> <span class="n">products</span><span class="p">:</span>
                <span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">products</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">products</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If n == 0, the rule was not applicable and we return None</span>
                <span class="k">return</span> <span class="n">mols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span></div>
            
    
<span class="c1">#==============================================================================</span>
<span class="c1"># from .tautomer import TAUTOMER_TRANSFORMS, TAUTOMER_SCORES, MAX_TAUTOMERS, TautomerCanonicalizer, TautomerEnumerator</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="TautomerTransform"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerTransform">[docs]</a><span class="k">class</span> <span class="nc">TautomerTransform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rules to transform one tautomer to another.</span>

<span class="sd">    Each TautomerTransform is defined by a SMARTS pattern where the transform involves moving a hydrogen from the first</span>
<span class="sd">    atom in the pattern to the last atom in the pattern. By default, alternating single and double bonds along the</span>
<span class="sd">    pattern are swapped accordingly to account for the hydrogen movement. If necessary, the transform can instead define</span>
<span class="sd">    custom resulting bond orders and also resulting atom charges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BONDMAP</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span> <span class="n">BondType</span><span class="o">.</span><span class="n">TRIPLE</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">:</span> <span class="n">BondType</span><span class="o">.</span><span class="n">AROMATIC</span><span class="p">}</span>
    <span class="n">CHARGEMAP</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="p">(),</span> <span class="n">charges</span><span class="o">=</span><span class="p">(),</span> <span class="n">radicals</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a TautomerTransform with a name, SMARTS pattern and optional bonds and charges.</span>

<span class="sd">        The SMARTS pattern match is applied to a Kekule form of the molecule, so use explicit single and double bonds</span>
<span class="sd">        rather than aromatic.</span>

<span class="sd">        Specify custom bonds as a string of ``-``, ``=``, ``#``, ``:`` for single, double, triple and aromatic bonds</span>
<span class="sd">        respectively. Specify custom charges as ``+``, ``0``, ``-`` for +1, 0 and -1 charges respectively.</span>

<span class="sd">        :param string name: A name for this TautomerTransform.</span>
<span class="sd">        :param string smarts: SMARTS pattern to match for the transform.</span>
<span class="sd">        :param string bonds: Optional specification for the resulting bonds.</span>
<span class="sd">        :param string charges: Optional specification for the resulting charges on the atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_str</span> <span class="o">=</span> <span class="n">smarts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BONDMAP</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CHARGEMAP</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">charges</span><span class="p">]</span>
        <span class="c1"># TODO: Raise error (ValueError?) if bonds and charges lists are not the correct length</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">tautomer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tautomer_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;TautomerTransform(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">charges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="TautomerScore"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerScore">[docs]</a><span class="k">class</span> <span class="nc">TautomerScore</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A substructure defined by SMARTS and its score contribution to determine the canonical tautomer.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a TautomerScore with a name, SMARTS pattern and score.</span>

<span class="sd">        :param name: A name for this TautomerScore.</span>
<span class="sd">        :param smarts: SMARTS pattern to match a substructure.</span>
<span class="sd">        :param score: The score to assign for this substructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span> <span class="o">=</span> <span class="n">smarts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">smarts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;TautomerScore(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="c1">#: The default list of TautomerTransforms.</span>
<span class="n">TAUTOMER_TRANSFORMS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,3 (thio)keto/enol f&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4!H0]-[C]=[O,S,Se,Te;X1]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,3 (thio)keto/enol r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,S,Se,Te;X2!H0]-[C]=[C]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,5 (thio)keto/enol f&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4,NX3;!H0]-[C]=[C][CH0]=[O,S,Se,Te;X1]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,5 (thio)keto/enol r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,S,Se,Te;X2!H0]-[CH0]=[C]-[C]=[C,N]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;aliphatic imine f&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4!H0]-[C]=[NX2]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;aliphatic imine r&#39;</span><span class="p">,</span> <span class="s1">&#39;[NX3!H0]-[C]=[CX3]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;special imine f&#39;</span><span class="p">,</span> <span class="s1">&#39;[N!H0]-[C]=[CX3R0]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;special imine r&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4!H0]-[c]=[n]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,3 aromatic heteroatom H shift f&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7!H0]-[#6R1]=[O,#7X2]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,3 aromatic heteroatom H shift r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,#7;!H0]-[#6R1]=[#7X2]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,3 heteroatom H shift&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,S,O,Se,Te;!H0]-[#7X2,#6,#15]=[#7,#16,#8,Se,Te]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,5 aromatic heteroatom H shift&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,#16,#8;!H0]-[#6,#7]=[#6]-[#6,#7]=[#7,#16,#8;H0]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,5 aromatic heteroatom H shift f&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,#16,#8,Se,Te;!H0]-[#6,nX2]=[#6,nX2]-[#6,#7X2]=[#7X2,S,O,Se,Te]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,5 aromatic heteroatom H shift r&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,S,O,Se,Te;!H0]-[#6,#7X2]=[#6,nX2]-[#6,nX2]=[#7,#16,#8,Se,Te]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,7 aromatic heteroatom H shift f&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,#8,#16,Se,Te;!H0]-[#6,#7X2]=[#6,#7X2]-[#6,#7X2]=[#6]-[#6,#7X2]=[#7X2,S,O,Se,Te,CX3]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,7 aromatic heteroatom H shift r&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,S,O,Se,Te,CX4;!H0]-[#6,#7X2]=[#6]-[#6,#7X2]=[#6,#7X2]-[#6,#7X2]=[NX2,S,O,Se,Te]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,9 aromatic heteroatom H shift f&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,O;!H0]-[#6,#7X2]=[#6,#7X2]-[#6,#7X2]=[#6,#7X2]-[#6,#7X2]=[#6,#7X2]-[#6,#7X2]=[#7,O]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;1,11 aromatic heteroatom H shift f&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7,O;!H0]-[#6,nX2]=[#6,nX2]-[#6,nX2]=[#6,nX2]-[#6,nX2]=[#6,nX2]-[#6,nX2]=[#6,nX2]-[#6,nX2]=[#7X2,O]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;furanone f&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,S,N;!H0]-[#6r5]=[#6X3r5;$([#6]([#6r5])=[#6r5])]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;furanone r&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6r5!H0;$([#6]([#6r5])[#6r5])]-[#6r5]=[O,S,N]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;keten/ynol f&#39;</span><span class="p">,</span> <span class="s1">&#39;[C!H0]=[C]=[O,S,Se,Te;X1]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;#-&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;keten/ynol r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O,S,Se,Te;!H0X2]-[C]#[C]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;==&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;ionic nitro/aci-nitro f&#39;</span><span class="p">,</span> <span class="s1">&#39;[C!H0]-[N+;$([N][O-])]=[O]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;ionic nitro/aci-nitro r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O!H0]-[N+;$([N][O-])]=[C]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;oxim/nitroso f&#39;</span><span class="p">,</span> <span class="s1">&#39;[O!H0]-[N]=[C]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;oxim/nitroso r&#39;</span><span class="p">,</span> <span class="s1">&#39;[C!H0]-[N]=[O]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;oxim/nitroso via phenol f&#39;</span><span class="p">,</span> <span class="s1">&#39;[O!H0]-[N]=[C]-[C]=[C]-[C]=[OH0]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;oxim/nitroso via phenol r&#39;</span><span class="p">,</span> <span class="s1">&#39;[O!H0]-[c]=[c]-[c]=[c]-[N]=[OH0]&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;cyano/iso-cyanic acid f&#39;</span><span class="p">,</span> <span class="s1">&#39;[O!H0]-[C]#[N]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;==&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;cyano/iso-cyanic acid r&#39;</span><span class="p">,</span> <span class="s1">&#39;[N!H0]=[C]=[O]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;#-&#39;</span><span class="p">),</span>
    <span class="c1"># TautomerTransform(&#39;formamidinesulfinic acid f&#39;, &#39;[O,N;!H0]-[C]=[S,Se,Te]=[O]&#39;, bonds=&#39;=--&#39;),  # TODO: WAT!?</span>
    <span class="c1"># TautomerTransform(&#39;formamidinesulfinic acid r&#39;, &#39;[O!H0]-[S,Se,Te]-[C]=[O,N]&#39;, bonds=&#39;=--&#39;),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;isocyanide f&#39;</span><span class="p">,</span> <span class="s1">&#39;[C-0!H0]#[N+0]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="s1">&#39;-+&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;isocyanide r&#39;</span><span class="p">,</span> <span class="s1">&#39;[N+!H0]#[C-]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="s1">&#39;-+&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;phosphonic acid f&#39;</span><span class="p">,</span> <span class="s1">&#39;[OH]-[PH0]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;=&#39;</span><span class="p">),</span>
    <span class="n">TautomerTransform</span><span class="p">(</span><span class="s1">&#39;phosphonic acid r&#39;</span><span class="p">,</span> <span class="s1">&#39;[PH]=[O]&#39;</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1">#: The default list of TautomerScores.</span>
<span class="n">TAUTOMER_SCORES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;benzoquinone&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]1([#6]=[#6][#6]([#6]=[#6]1)=,:[N,S,O])=,:[N,S,O]&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;oxim&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]=[N][OH]&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;C=O&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]=,:[#8]&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;N=O&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7]=,:[#8]&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;P=O&#39;</span><span class="p">,</span> <span class="s1">&#39;[#15]=,:[#8]&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;C=hetero&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]=[!#1;!#6]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;methyl&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4H3]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;guanidine terminal=N&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7][#6](=[NR0])[#7H0]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;guanidine endocyclic=N&#39;</span><span class="p">,</span> <span class="s1">&#39;[#7;R][#6;R]([N])=[#7;R]&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">TautomerScore</span><span class="p">(</span><span class="s1">&#39;aci-nitro&#39;</span><span class="p">,</span> <span class="s1">&#39;[#6]=[N+]([O-])[OH]&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1">#: The default value for the maximum number of tautomers to enumerate, a limit to prevent combinatorial explosion.</span>
<span class="n">MAX_TAUTOMERS</span> <span class="o">=</span> <span class="mi">1000</span>


<div class="viewcode-block" id="TautomerCanonicalizer"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerCanonicalizer">[docs]</a><span class="k">class</span> <span class="nc">TautomerCanonicalizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="n">TAUTOMER_TRANSFORMS</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="n">TAUTOMER_SCORES</span><span class="p">,</span> <span class="n">max_tautomers</span><span class="o">=</span><span class="n">MAX_TAUTOMERS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param transforms: A list of TautomerTransforms to use to enumerate tautomers.</span>
<span class="sd">        :param scores: A list of TautomerScores to use to choose the canonical tautomer.</span>
<span class="sd">        :param max_tautomers: The maximum number of tautomers to enumerate, a limit to prevent combinatorial explosion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span> <span class="o">=</span> <span class="n">max_tautomers</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a TautomerCanonicalizer instance like a function is the same as calling its canonicalize(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="TautomerCanonicalizer.canonicalize"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerCanonicalizer.canonicalize">[docs]</a>    <span class="k">def</span> <span class="nf">canonicalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a canonical tautomer by enumerating and scoring all possible tautomers.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The canonical tautomer.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Overload the mol parameter to pass a list of pre-enumerated tautomers</span>
        <span class="n">tautomers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enumerate_tautomers</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tautomers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tautomers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Calculate score for each tautomer</span>
        <span class="n">highest</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Tautomer: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Add aromatic ring scores</span>
            <span class="n">ssr</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetSymmSSSR</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ssr</span><span class="p">:</span>
                <span class="n">btypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">ring</span><span class="p">)}</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">btypes</span> <span class="o">==</span> <span class="p">{</span><span class="n">BondType</span><span class="o">.</span><span class="n">AROMATIC</span><span class="p">}:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Score +100 (aromatic ring)&#39;</span><span class="p">)</span>
                    <span class="n">score</span> <span class="o">+=</span> <span class="mi">100</span>
                    <span class="k">if</span> <span class="n">elements</span> <span class="o">==</span> <span class="p">{</span><span class="mi">6</span><span class="p">}:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Score +150 (carbocyclic aromatic ring)&#39;</span><span class="p">)</span>
                        <span class="n">score</span> <span class="o">+=</span> <span class="mi">150</span>
            <span class="c1"># Add SMARTS scores</span>
            <span class="k">for</span> <span class="n">tscore</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">tscore</span><span class="o">.</span><span class="n">smarts</span><span class="p">):</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Score </span><span class="si">%+d</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">tscore</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">tscore</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">score</span> <span class="o">+=</span> <span class="n">tscore</span><span class="o">.</span><span class="n">score</span>
            <span class="c1"># Add (P,S,Se,Te)-H scores</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">52</span><span class="p">}:</span>
                    <span class="n">hs</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">hs</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Score </span><span class="si">%+d</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">-H bonds)&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">hs</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">())</span>
                        <span class="n">score</span> <span class="o">-=</span> <span class="n">hs</span>
            <span class="c1"># Set as highest if score higher or if score equal and smiles comes first alphabetically</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">highest</span> <span class="ow">or</span> <span class="n">highest</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">score</span> <span class="ow">or</span> <span class="p">(</span><span class="n">highest</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">score</span> <span class="ow">and</span> <span class="n">smiles</span> <span class="o">&lt;</span> <span class="n">highest</span><span class="p">[</span><span class="s1">&#39;smiles&#39;</span><span class="p">]):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New highest tautomer: </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
                <span class="n">highest</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;smiles&#39;</span><span class="p">:</span> <span class="n">smiles</span><span class="p">,</span> <span class="s1">&#39;tautomer&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">:</span> <span class="n">score</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">highest</span><span class="p">[</span><span class="s1">&#39;tautomer&#39;</span><span class="p">]</span></div>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">_enumerate_tautomers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TautomerEnumerator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span><span class="p">)</span></div>


<div class="viewcode-block" id="TautomerEnumerator"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerEnumerator">[docs]</a><span class="k">class</span> <span class="nc">TautomerEnumerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="n">TAUTOMER_TRANSFORMS</span><span class="p">,</span> <span class="n">max_tautomers</span><span class="o">=</span><span class="n">MAX_TAUTOMERS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param transforms: A list of TautomerTransforms to use to enumerate tautomers.</span>
<span class="sd">        :param max_tautomers: The maximum number of tautomers to enumerate (limit to prevent combinatorial explosion).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span> <span class="o">=</span> <span class="n">max_tautomers</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a TautomerEnumerator instance like a function is the same as calling its enumerate(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="TautomerEnumerator.enumerate"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.TautomerEnumerator.enumerate">[docs]</a>    <span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enumerate all possible tautomers and return them as a list.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: A list of all possible tautomers of the molecule.</span>
<span class="sd">        :rtype: list of rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tautomers</span> <span class="o">=</span> <span class="p">{</span><span class="n">smiles</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)}</span>
        <span class="c1"># Create a kekulized form of the molecule to match the SMARTS against</span>
        <span class="n">kekulized</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">kekulized</span><span class="p">)</span>
        <span class="n">kekulized</span> <span class="o">=</span> <span class="p">{</span><span class="n">smiles</span><span class="p">:</span> <span class="n">kekulized</span><span class="p">}</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tautomers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tsmiles</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tautomers</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tsmiles</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">kekulized</span><span class="p">[</span><span class="n">tsmiles</span><span class="p">]</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">tautomer</span><span class="p">):</span>
                        <span class="c1"># log.debug(&#39;Matched rule: %s to %s for %s&#39;, transform.name, tsmiles, match)</span>
                        <span class="c1"># Create a copy of in the input molecule so we can modify it</span>
                        <span class="c1"># Use kekule form so bonds are explicitly single/double instead of aromatic</span>
                        <span class="n">product</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kekulized</span><span class="p">[</span><span class="n">tsmiles</span><span class="p">])</span>
                        <span class="c1"># Remove a hydrogen from the first matched atom and add one to the last</span>
                        <span class="n">first</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">last</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="c1"># log.debug(&#39;%s: H%s -&gt; H%s&#39; % (first.GetSymbol(), first.GetTotalNumHs(), first.GetTotalNumHs() - 1))</span>
                        <span class="c1"># log.debug(&#39;%s: H%s -&gt; H%s&#39; % (last.GetSymbol(), last.GetTotalNumHs(), last.GetTotalNumHs() + 1))</span>
                        <span class="n">first</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">first</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">last</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">last</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="c1"># Remove any implicit hydrogens from the first and last atoms now we have set the count explicitly</span>
                        <span class="n">first</span><span class="o">.</span><span class="n">SetNoImplicit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">last</span><span class="o">.</span><span class="n">SetNoImplicit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># Adjust bond orders</span>
                        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairwise</span><span class="p">(</span><span class="n">match</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="n">transform</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                                <span class="c1"># Set the resulting bond types as manually specified in the transform</span>
                                <span class="c1"># log.debug(&#39;%s-%s: %s -&gt; %s&#39; % (product.GetAtomWithIdx(pair[0]).GetSymbol(), product.GetAtomWithIdx(pair[1]).GetSymbol(), product.GetBondBetweenAtoms(*pair).GetBondType(), transform.bonds[bi]))</span>
                                <span class="n">product</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="n">bi</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># If no manually specified bond types, just swap single and double bonds</span>
                                <span class="n">current_bond_type</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
                                <span class="n">product</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span> <span class="k">if</span> <span class="n">current_bond_type</span> <span class="o">==</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span> <span class="k">else</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
                                <span class="c1"># log.debug(&#39;%s-%s: %s -&gt; %s&#39; % (product.GetAtomWithIdx(pair[0]).GetSymbol(), product.GetAtomWithIdx(pair[1]).GetSymbol(), current_bond_type, product.GetBondBetweenAtoms(*pair).GetBondType()))</span>
                        <span class="c1"># Adjust charges</span>
                        <span class="k">if</span> <span class="n">transform</span><span class="o">.</span><span class="n">charges</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                                <span class="n">atom</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                                <span class="c1"># log.debug(&#39;%s: C%s -&gt; C%s&#39; % (atom.GetSymbol(), atom.GetFormalCharge(), atom.GetFormalCharge() + transform.charges[ci]))</span>
                                <span class="n">atom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">+</span> <span class="n">transform</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="n">ci</span><span class="p">])</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
                            <span class="n">smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Applied rule: </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tsmiles</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">smiles</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="p">:</span>
                                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;New tautomer produced: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">smiles</span><span class="p">)</span>
                                <span class="n">kekulized_product</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
                                <span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">kekulized_product</span><span class="p">)</span>
                                <span class="n">tautomers</span><span class="p">[</span><span class="n">smiles</span><span class="p">]</span> <span class="o">=</span> <span class="n">product</span>
                                <span class="n">kekulized</span><span class="p">[</span><span class="n">smiles</span><span class="p">]</span> <span class="o">=</span> <span class="n">kekulized_product</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Previous tautomer produced again: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">smiles</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;ValueError Applying rule: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tsmiles</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tautomers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">done</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Tautomer enumeration stopped at maximum </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span><span class="p">)</span>
        <span class="c1"># Clean up stereochemistry</span>
        <span class="k">for</span> <span class="n">tautomer</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">tautomer</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">tautomer</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">==</span> <span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span> <span class="ow">and</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOANY</span><span class="p">:</span>
                    <span class="n">begin</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">othertautomer</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">othertautomer</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">==</span> <span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">tautomer</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">()</span> <span class="o">+</span> <span class="n">tautomer</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">otherbond</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">otherbond</span><span class="o">.</span><span class="n">GetBondDir</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="n">BondDir</span><span class="o">.</span><span class="n">ENDUPRIGHT</span><span class="p">,</span> <span class="n">BondDir</span><span class="o">.</span><span class="n">ENDDOWNRIGHT</span><span class="p">}:</span>
                                    <span class="n">otherbond</span><span class="o">.</span><span class="n">SetBondDir</span><span class="p">(</span><span class="n">BondDir</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
                            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">tautomer</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Removed stereochemistry from unfixed double bond&#39;</span><span class="p">)</span>
                            <span class="k">break</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">tautomers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div></div>
    
<span class="c1">#==============================================================================</span>
<span class="c1"># from .charge import ACID_BASE_PAIRS, Reionizer, Uncharger</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="AcidBasePair"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.AcidBasePair">[docs]</a><span class="k">class</span> <span class="nc">AcidBasePair</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An acid and its conjugate base, defined by SMARTS.</span>

<span class="sd">    A strength-ordered list of AcidBasePairs can be used to ensure the strongest acids in a molecule ionize first.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">acid</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an AcidBasePair with the following parameters:</span>

<span class="sd">        :param string name: A name for this AcidBasePair.</span>
<span class="sd">        :param string acid: SMARTS pattern for the protonated acid.</span>
<span class="sd">        :param string base: SMARTS pattern for the conjugate ionized base.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing AcidBasePair: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acid_str</span> <span class="o">=</span> <span class="n">acid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_str</span> <span class="o">=</span> <span class="n">base</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">acid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading AcidBasePair acid: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_str</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading AcidBasePair base: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;AcidBasePair(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acid_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="c1">#: The default list of AcidBasePairs, sorted from strongest to weakest. This list is derived from the Food and Drug</span>
<span class="c1">#: Administration Substance Registration System Standard Operating Procedure guide.</span>
<span class="n">ACID_BASE_PAIRS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-OSO3H&#39;</span><span class="p">,</span> <span class="s1">&#39;OS(=O)(=O)[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;OS(=O)(=O)[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;â€“SO3H&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]S(=O)(=O)[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]S(=O)(=O)[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-OSO2H&#39;</span><span class="p">,</span> <span class="s1">&#39;O[SD3](=O)[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;O[SD3](=O)[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-SO2H&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O][SD3](=O)[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O][SD3](=O)[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-OPO3H2&#39;</span><span class="p">,</span> <span class="s1">&#39;OP(=O)([OH])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;OP(=O)([OH])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-PO3H2&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]P(=O)([OH])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]P(=O)([OH])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-CO2H&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;thiophenol&#39;</span><span class="p">,</span> <span class="s1">&#39;c[SH]&#39;</span><span class="p">,</span> <span class="s1">&#39;c[S-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;(-OPO3H)-&#39;</span><span class="p">,</span> <span class="s1">&#39;OP(=O)([O-])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;OP(=O)([O-])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;(-PO3H)-&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]P(=O)([O-])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]P(=O)([O-])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;phthalimide&#39;</span><span class="p">,</span> <span class="s1">&#39;O=C2c1ccccc1C(=O)[NH]2&#39;</span><span class="p">,</span> <span class="s1">&#39;O=C2c1ccccc1C(=O)[N-]2&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;CO3H (peracetyl)&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)O[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)O[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;alpha-carbon-hydrogen-nitro group&#39;</span><span class="p">,</span> <span class="s1">&#39;O=N(O)[CH]&#39;</span><span class="p">,</span> <span class="s1">&#39;O=N(O)[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-SO2NH2&#39;</span><span class="p">,</span> <span class="s1">&#39;S(=O)(=O)[NH2]&#39;</span><span class="p">,</span> <span class="s1">&#39;S(=O)(=O)[NH-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-OBO2H2&#39;</span><span class="p">,</span> <span class="s1">&#39;OB([OH])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;OB([OH])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-BO2H2&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]B([OH])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]B([OH])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;phenol&#39;</span><span class="p">,</span> <span class="s1">&#39;c[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;c[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;SH (aliphatic)&#39;</span><span class="p">,</span> <span class="s1">&#39;C[SH]&#39;</span><span class="p">,</span> <span class="s1">&#39;C[S-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;(-OBO2H)-&#39;</span><span class="p">,</span> <span class="s1">&#39;OB([O-])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;OB([O-])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;(-BO2H)-&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]B([O-])[OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[!O]B([O-])[O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;cyclopentadiene&#39;</span><span class="p">,</span> <span class="s1">&#39;C1=CC=C[CH2]1&#39;</span><span class="p">,</span> <span class="s1">&#39;c1ccc[cH-]1&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-CONH2&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)[NH2]&#39;</span><span class="p">,</span> <span class="s1">&#39;C(=O)[NH-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;imidazole&#39;</span><span class="p">,</span> <span class="s1">&#39;c1cnc[nH]1&#39;</span><span class="p">,</span> <span class="s1">&#39;c1cnc[n-]1&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-OH (aliphatic alcohol)&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4][OH]&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4][O-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;alpha-carbon-hydrogen-keto group&#39;</span><span class="p">,</span> <span class="s1">&#39;O=C([!O])[C!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;O=C([!O])[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;alpha-carbon-hydrogen-acetyl ester group&#39;</span><span class="p">,</span> <span class="s1">&#39;OC(=O)[C!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;OC(=O)[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;sp carbon hydrogen&#39;</span><span class="p">,</span> <span class="s1">&#39;C#[CH]&#39;</span><span class="p">,</span> <span class="s1">&#39;C#[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;alpha-carbon-hydrogen-sulfone group&#39;</span><span class="p">,</span> <span class="s1">&#39;CS(=O)(=O)[C!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;CS(=O)(=O)[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;alpha-carbon-hydrogen-sulfoxide group&#39;</span><span class="p">,</span> <span class="s1">&#39;C[SD3](=O)[C!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;C[SD3](=O)[C-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;-NH2&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4][NH2]&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4][NH-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;benzyl hydrogen&#39;</span><span class="p">,</span> <span class="s1">&#39;c[CX4H2]&#39;</span><span class="p">,</span> <span class="s1">&#39;c[CX3H-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;sp2-carbon hydrogen&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX3]=[CX3!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX3]=[CX2-]&#39;</span><span class="p">),</span>
    <span class="n">AcidBasePair</span><span class="p">(</span><span class="s1">&#39;sp3-carbon hydrogen&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX4!H0+0]&#39;</span><span class="p">,</span> <span class="s1">&#39;[CX3-]&#39;</span><span class="p">),</span>
<span class="p">)</span>


<div class="viewcode-block" id="ChargeCorrection"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.ChargeCorrection">[docs]</a><span class="k">class</span> <span class="nc">ChargeCorrection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An atom that should have a certain charge applied, defined by a SMARTS pattern.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a ChargeCorrection with the following parameters:</span>

<span class="sd">        :param string name: A name for this ForcedAtomCharge.</span>
<span class="sd">        :param string smarts: SMARTS pattern to match. Charge is applied to the first atom.</span>
<span class="sd">        :param int charge: The charge to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing ChargeCorrection: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span> <span class="o">=</span> <span class="n">smarts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">smarts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading ChargeCorrection smarts: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;ChargeCorrection(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smarts_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="c1">#: The default list of ChargeCorrections.</span>
<span class="n">CHARGE_CORRECTIONS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ChargeCorrection</span><span class="p">(</span><span class="s1">&#39;[Li,Na,K]&#39;</span><span class="p">,</span> <span class="s1">&#39;[Li,Na,K;X0+0]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">ChargeCorrection</span><span class="p">(</span><span class="s1">&#39;[Mg,Ca]&#39;</span><span class="p">,</span> <span class="s1">&#39;[Mg,Ca;X0+0]&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">ChargeCorrection</span><span class="p">(</span><span class="s1">&#39;[Cl]&#39;</span><span class="p">,</span> <span class="s1">&#39;[Cl;X0+0]&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="c1"># TODO: Extend to other incorrectly charged atoms</span>
<span class="p">)</span>


<div class="viewcode-block" id="Reionizer"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Reionizer">[docs]</a><span class="k">class</span> <span class="nc">Reionizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to fix charges and reionize a molecule such that the strongest acids ionize first.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acid_base_pairs</span><span class="o">=</span><span class="n">ACID_BASE_PAIRS</span><span class="p">,</span> <span class="n">charge_corrections</span><span class="o">=</span><span class="n">CHARGE_CORRECTIONS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Reionizer with the following parameter:</span>

<span class="sd">        :param acid_base_pairs: A list of :class:`AcidBasePairs &lt;molvs.charge.AcidBasePair&gt;` to reionize, sorted from</span>
<span class="sd">                                strongest to weakest.</span>
<span class="sd">        :param charge_corrections: A list of :class:`ChargeCorrections &lt;molvs.charge.ChargeCorrection&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing Reionizer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span> <span class="o">=</span> <span class="n">acid_base_pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_corrections</span> <span class="o">=</span> <span class="n">charge_corrections</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a Reionizer instance like a function is the same as calling its reionize(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reionize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Reionizer.reionize"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Reionizer.reionize">[docs]</a>    <span class="k">def</span> <span class="nf">reionize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enforce charges on certain atoms, then perform competitive reionization.</span>

<span class="sd">        First, charge corrections are applied to ensure, for example, that free metals are correctly ionized. Then, if</span>
<span class="sd">        a molecule with multiple acid groups is partially ionized, ensure the strongest acids ionize first.</span>

<span class="sd">        The algorithm works as follows:</span>

<span class="sd">        - Use SMARTS to find the strongest protonated acid and the weakest ionized acid.</span>
<span class="sd">        - If the ionized acid is weaker than the protonated acid, swap proton and repeat.</span>

<span class="sd">        :param mol: The molecule to reionize.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The reionized molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running Reionizer&#39;</span><span class="p">)</span>

        <span class="n">start_charge</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="c1"># Apply forced charge corrections</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_corrections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">smarts</span><span class="p">):</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying charge correction </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1"> </span><span class="si">%+d</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">(),</span> <span class="n">cc</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>

        <span class="n">current_charge</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">charge_diff</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_charge</span>
        <span class="c1"># If molecule is now neutral, assume everything is now fixed</span>
        <span class="c1"># But otherwise, if charge has become more positive, look for additional protonated acid groups to ionize</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current_charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">charge_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ppos</span><span class="p">,</span> <span class="n">poccur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strongest_protonated</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ppos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Ionizing </span><span class="si">%s</span><span class="s1"> to balance previous charge corrections&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">patom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">poccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">patom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">patom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">patom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">patom</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">patom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># else:</span>
                <span class="n">patom</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">()</span>
                <span class="n">charge_diff</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">already_moved</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ppos</span><span class="p">,</span> <span class="n">poccur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strongest_protonated</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
            <span class="n">ipos</span><span class="p">,</span> <span class="n">ioccur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weakest_ionized</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ioccur</span> <span class="ow">and</span> <span class="n">poccur</span> <span class="ow">and</span> <span class="n">ppos</span> <span class="o">&lt;</span> <span class="n">ipos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">poccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ioccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># Bad! H wouldn&#39;t be moved, resulting in infinite loop.</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Aborted reionization due to unexpected situation&#39;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">poccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ioccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">already_moved</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Aborting reionization to avoid infinite loop due to it being ambiguous where to put a Hydrogen&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">already_moved</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Moved proton from </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">[</span><span class="n">ipos</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                <span class="c1"># Remove hydrogen from strongest protonated</span>
                <span class="n">patom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">poccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">patom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">patom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># If no implicit Hs to autoremove, and at least 1 explicit H to remove, reduce explicit count by 1</span>
                <span class="k">if</span> <span class="n">patom</span><span class="o">.</span><span class="n">GetNumImplicitHs</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">patom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">patom</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">patom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># TODO: Remove any chiral label on patom?</span>
                <span class="n">patom</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">()</span>

                <span class="c1"># Add hydrogen to weakest ionized</span>
                <span class="n">iatom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">ioccur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">iatom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">iatom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Increase explicit H count if no implicit, or aromatic N or P, or non default valence state</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iatom</span><span class="o">.</span><span class="n">GetNoImplicit</span><span class="p">()</span> <span class="ow">or</span>
                        <span class="p">((</span><span class="n">patom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">7</span> <span class="ow">or</span> <span class="n">patom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="ow">and</span> <span class="n">patom</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">())</span> <span class="ow">or</span>
                        <span class="n">iatom</span><span class="o">.</span><span class="n">GetTotalValence</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">GetPeriodicTable</span><span class="p">()</span><span class="o">.</span><span class="n">GetValenceList</span><span class="p">(</span><span class="n">iatom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()))):</span>
                    <span class="n">iatom</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">iatom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">iatom</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># TODO: Canonical ionization position if multiple equivalent positions?</span>

        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

    <span class="k">def</span> <span class="nf">_strongest_protonated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">occurrence</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">acid</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">occurrence</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_weakest_ionized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">occurrence</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">)</span> <span class="o">-</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">occurrence</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Uncharger"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Uncharger">[docs]</a><span class="k">class</span> <span class="nc">Uncharger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for neutralizing charges in a molecule.</span>

<span class="sd">    This class uncharges molecules by adding and/or removing hydrogens. In cases where there is a positive charge that</span>
<span class="sd">    is not neutralizable, any corresponding negative charge is also preserved.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acid_base_pairs</span><span class="o">=</span><span class="n">ACID_BASE_PAIRS</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing Uncharger&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span> <span class="o">=</span> <span class="n">acid_base_pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nitro</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[!#8][NX3+](=O)[O-]&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling an Uncharger instance like a function is the same as calling its uncharge(mol) method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncharge</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Uncharger.uncharge"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Uncharger.uncharge">[docs]</a>    <span class="k">def</span> <span class="nf">uncharge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Neutralize molecule by adding/removing hydrogens.</span>

<span class="sd">        :param mol: The molecule to uncharge.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :return: The uncharged molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running Uncharger&#39;</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="c1"># Neutralize positive charges</span>
        <span class="n">pos_remainder</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">neg_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="c1"># Remove hydrogen from positive atoms and reduce formal change until neutral or no more hydrogens</span>
            <span class="k">while</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removed positive charge&#39;</span><span class="p">)</span>
            <span class="n">chg</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">chg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Record number of non-neutralizable positive charges</span>
                <span class="n">pos_remainder</span> <span class="o">+=</span> <span class="n">chg</span>
            <span class="k">elif</span> <span class="n">chg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Record total number of negative charges</span>
                <span class="n">neg_count</span> <span class="o">+=</span> <span class="o">-</span><span class="n">chg</span>

        <span class="c1"># Choose negative charges to leave in order to balance non-neutralizable positive charges</span>
        <span class="n">neg_skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_neg_skip</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">pos_remainder</span><span class="p">)</span>

        <span class="c1"># Neutralize remaining negative charges</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="ow">in</span> <span class="n">neg_skip</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Make sure to stop when neg_count &lt;= pos_remainder, as it is possible that neg_skip is not large enough</span>
            <span class="k">while</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">neg_count</span> <span class="o">&gt;</span> <span class="n">pos_remainder</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetNumExplicitHs</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetNumExplicitHs</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">neg_count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removed negative charge&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

    <span class="k">def</span> <span class="nf">_get_neg_skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">pos_count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get negatively charged atoms to skip (up to pos_count).&quot;&quot;&quot;</span>
        <span class="n">neg_skip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos_count</span><span class="p">:</span>
            <span class="c1"># Get negative oxygens in charge-separated nitro groups TODO: Any other special cases to skip?</span>
            <span class="k">for</span> <span class="n">occurrence</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nitro</span><span class="p">):</span>
                <span class="n">neg_skip</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">occurrence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_skip</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">pos_count</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">neg_skip</span>
            <span class="c1"># Get strongest ionized acids</span>
            <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">occurrence</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
                    <span class="n">neg_skip</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">occurrence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_skip</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">pos_count</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">neg_skip</span>
        <span class="k">return</span> <span class="n">neg_skip</span></div>



<div class="viewcode-block" id="Standardizer"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer">[docs]</a><span class="k">class</span> <span class="nc">Standardizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The main class for performing standardization of molecules and deriving parent molecules.</span>

<span class="sd">    The primary usage is via the :meth:`~molvs.standardize.Standardizer.standardize` method::</span>

<span class="sd">        s = Standardizer()</span>
<span class="sd">        mol1 = Chem.MolFromSmiles(&#39;C1=CC=CC=C1&#39;)</span>
<span class="sd">        mol2 = s.standardize(mol1)</span>

<span class="sd">    There are separate methods to derive fragment, charge, tautomer, isotope and stereo parent molecules.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalizations</span><span class="o">=</span><span class="n">NORMALIZATIONS</span><span class="p">,</span> <span class="n">acid_base_pairs</span><span class="o">=</span><span class="n">ACID_BASE_PAIRS</span><span class="p">,</span>
                 <span class="n">charge_corrections</span><span class="o">=</span><span class="n">CHARGE_CORRECTIONS</span><span class="p">,</span> <span class="n">tautomer_transforms</span><span class="o">=</span><span class="n">TAUTOMER_TRANSFORMS</span><span class="p">,</span>
                 <span class="n">tautomer_scores</span><span class="o">=</span><span class="n">TAUTOMER_SCORES</span><span class="p">,</span> <span class="n">max_restarts</span><span class="o">=</span><span class="n">MAX_RESTARTS</span><span class="p">,</span> <span class="n">max_tautomers</span><span class="o">=</span><span class="n">MAX_TAUTOMERS</span><span class="p">,</span>
                 <span class="n">prefer_organic</span><span class="o">=</span><span class="n">PREFER_ORGANIC</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Standardizer with optional custom parameters.</span>

<span class="sd">        :param normalizations: A list of Normalizations to apply (default: :data:`~molvs.normalize.NORMALIZATIONS`).</span>
<span class="sd">        :param acid_base_pairs: A list of AcidBasePairs for competitive reionization (default:</span>
<span class="sd">                                :data:`~molvs.charge.ACID_BASE_PAIRS`).</span>
<span class="sd">        :param charge_corrections: A list of ChargeCorrections to apply (default:</span>
<span class="sd">                                :data:`~molvs.charge.CHARGE_CORRECTIONS`).</span>
<span class="sd">        :param tautomer_transforms: A list of TautomerTransforms to apply (default:</span>
<span class="sd">                                    :data:`~molvs.tautomer.TAUTOMER_TRANSFORMS`).</span>
<span class="sd">        :param tautomer_scores: A list of TautomerScores used to determine canonical tautomer (default:</span>
<span class="sd">                                :data:`~molvs.tautomer.TAUTOMER_SCORES`).</span>
<span class="sd">        :param max_restarts: The maximum number of times to attempt to apply the series of normalizations (default 200).</span>
<span class="sd">        :param max_tautomers: The maximum number of tautomers to enumerate (default 1000).</span>
<span class="sd">        :param prefer_organic: Whether to prioritize organic fragments when choosing fragment parent (default False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing Standardizer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizations</span> <span class="o">=</span> <span class="n">normalizations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span> <span class="o">=</span> <span class="n">acid_base_pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_corrections</span> <span class="o">=</span> <span class="n">charge_corrections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_transforms</span> <span class="o">=</span> <span class="n">tautomer_transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_scores</span> <span class="o">=</span> <span class="n">tautomer_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_restarts</span> <span class="o">=</span> <span class="n">max_restarts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span> <span class="o">=</span> <span class="n">max_tautomers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefer_organic</span> <span class="o">=</span> <span class="n">prefer_organic</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a Standardizer instance like a function is the same as calling its</span>
<span class="sd">        :meth:`~molvs.standardize.Standardizer.standardize` method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Standardizer.standardize"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.standardize">[docs]</a>    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a standardized version the given molecule.</span>

<span class="sd">        The standardization process consists of the following stages: RDKit</span>
<span class="sd">        :py:func:`~rdkit.Chem.rdmolops.RemoveHs`, RDKit :py:func:`~rdkit.Chem.rdmolops.SanitizeMol`,</span>
<span class="sd">        :class:`~molvs.metal.MetalDisconnector`, :class:`~molvs.normalize.Normalizer`,</span>
<span class="sd">        :class:`~molvs.charge.Reionizer`, RDKit :py:func:`~rdkit.Chem.rdmolops.AssignStereochemistry`.</span>

<span class="sd">        :param mol: The molecule to standardize.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :returns: The standardized molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">disconnect_metals</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reionize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># TODO: Check this removes symmetric stereocenters</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Standardizer.tautomer_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.tautomer_parent">[docs]</a>    <span class="k">def</span> <span class="nf">tautomer_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tautomer parent of a given molecule.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The tautomer parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">tautomer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalize_tautomer</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">tautomer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">tautomer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tautomer</span></div>

<div class="viewcode-block" id="Standardizer.fragment_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.fragment_parent">[docs]</a>    <span class="k">def</span> <span class="nf">fragment_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the fragment parent of a given molecule.</span>

<span class="sd">        The fragment parent is the largest organic covalent unit in the molecule.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The fragment parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="c1"># TODO: Consider applying FragmentRemover first to remove salts, solvents?</span>
        <span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largest_fragment</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fragment</span></div>

<div class="viewcode-block" id="Standardizer.stereo_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.stereo_parent">[docs]</a>    <span class="k">def</span> <span class="nf">stereo_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the stereo parent of a given molecule.</span>

<span class="sd">        The stereo parent has all stereochemistry information removed from tetrahedral centers and double bonds.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The stereo parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveStereochemistry</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Standardizer.isotope_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.isotope_parent">[docs]</a>    <span class="k">def</span> <span class="nf">isotope_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the isotope parent of a given molecule.</span>

<span class="sd">        The isotope parent has all atoms replaced with the most abundant isotope for that element.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The isotope parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="c1"># Replace isotopes with common weight</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetIsotope</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Standardizer.charge_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.charge_parent">[docs]</a>    <span class="k">def</span> <span class="nf">charge_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the charge parent of a given molecule.</span>

<span class="sd">        The charge parent is the uncharged version of the fragment parent.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The charge parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: All ionized acids and bases should be neutralised.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_parent</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fragment</span><span class="p">:</span>
            <span class="n">uncharged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncharge</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>
            <span class="c1"># During final standardization, the Reionizer ensures any remaining charges are in the right places</span>
            <span class="n">uncharged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">uncharged</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">uncharged</span></div>

<div class="viewcode-block" id="Standardizer.super_parent"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.super_parent">[docs]</a>    <span class="k">def</span> <span class="nf">super_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the super parent of a given molecule.</span>

<span class="sd">        THe super parent is fragment, charge, isotope, stereochemistry and tautomer insensitive. From the input</span>
<span class="sd">        molecule, the largest fragment is taken. This is uncharged and then isotope and stereochemistry information is</span>
<span class="sd">        discarded. Finally, the canonical tautomer is determined and returned.</span>

<span class="sd">        :param mol: The input molecule.</span>
<span class="sd">        :type mol: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        :param bool skip_standardize: Set to True if mol has already been standardized.</span>
<span class="sd">        :returns: The super parent molecule.</span>
<span class="sd">        :rtype: rdkit.Chem.rdchem.Mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_standardize</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="c1"># We don&#39;t need to get fragment parent, because the charge parent is the largest fragment</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_parent</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isotope_parent</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereo_parent</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_parent</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="Standardizer.standardize_with_parents"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.standardize_with_parents">[docs]</a>    <span class="k">def</span> <span class="nf">standardize_with_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="n">standardized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">tautomer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tautomer_parent</span><span class="p">(</span><span class="n">standardized</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">super</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_parent</span><span class="p">(</span><span class="n">standardized</span><span class="p">,</span> <span class="n">skip_standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># TODO: Add other parents - have optional argument to specify which are wanted</span>
        <span class="n">mols</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;standardized&#39;</span><span class="p">:</span> <span class="n">standardized</span><span class="p">,</span>
            <span class="s1">&#39;tautomer_parent&#39;</span><span class="p">:</span> <span class="n">tautomer</span><span class="p">,</span>
            <span class="s1">&#39;super_parent&#39;</span><span class="p">:</span> <span class="nb">super</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">mols</span></div>

    <span class="c1"># TODO: All unique tautomers</span>
    <span class="c1"># TODO: All unique fragments (each has to be standardized again?)</span>
    
<div class="viewcode-block" id="Standardizer.addhs"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.addhs">[docs]</a>    <span class="k">def</span> <span class="nf">addhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mol</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AddHs</span>
        <span class="k">return</span> <span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="Standardizer.rmhs"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Standardizer.rmhs">[docs]</a>    <span class="k">def</span> <span class="nf">rmhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">RemoveHs</span>
        <span class="k">return</span> <span class="n">RemoveHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span></div>
    
    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">disconnect_metals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.metal.MetalDisconnector` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MetalDisconnector</span><span class="p">()</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.normalize.Normalizer` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Normalizer</span><span class="p">(</span><span class="n">normalizations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalizations</span><span class="p">,</span> <span class="n">max_restarts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_restarts</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">reionize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.charge.Reionizer` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Reionizer</span><span class="p">(</span><span class="n">acid_base_pairs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">,</span> <span class="n">charge_corrections</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_corrections</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">uncharge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.charge.Uncharger` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Uncharger</span><span class="p">(</span><span class="n">acid_base_pairs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acid_base_pairs</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">remove_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.fragment.FragmentRemover` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FragmentRemover</span><span class="p">()</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">largest_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.fragment.LargestFragmentChooser` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LargestFragmentChooser</span><span class="p">(</span><span class="n">prefer_organic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefer_organic</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">enumerate_tautomers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.tautomer.TautomerEnumerator` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TautomerEnumerator</span><span class="p">(</span><span class="n">transforms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tautomer_transforms</span><span class="p">,</span> <span class="n">max_tautomers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">canonicalize_tautomer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A callable :class:`~molvs.tautomer.TautomerCanonicalizer` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TautomerCanonicalizer</span><span class="p">(</span><span class="n">transforms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tautomer_transforms</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tautomer_scores</span><span class="p">,</span>
                                     <span class="n">max_tautomers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tautomers</span><span class="p">)</span></div>


<div class="viewcode-block" id="standardize_smiles"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.standardize_smiles">[docs]</a><span class="k">def</span> <span class="nf">standardize_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a standardized canonical SMILES string given a SMILES string.</span>

<span class="sd">    Note: This is a convenience function for quickly standardizing a single SMILES string. It is more efficient to use</span>
<span class="sd">    the :class:`~molvs.standardize.Standardizer` class directly when working with many molecules or when custom options</span>
<span class="sd">    are needed.</span>

<span class="sd">    :param string smiles: The SMILES for the molecule.</span>
<span class="sd">    :returns: The SMILES for the standardized molecule.</span>
<span class="sd">    :rtype: string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Skip sanitize as standardize does this anyway</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Standardizer</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="enumerate_tautomers_smiles"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.enumerate_tautomers_smiles">[docs]</a><span class="k">def</span> <span class="nf">enumerate_tautomers_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a set of tautomers as SMILES strings, given a SMILES string.</span>

<span class="sd">    :param smiles: A SMILES string.</span>
<span class="sd">    :returns: A set containing SMILES strings for every possible tautomer.</span>
<span class="sd">    :rtype: set of strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Skip sanitize as standardize does this anyway</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Standardizer</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">tautomers</span> <span class="o">=</span> <span class="n">TautomerEnumerator</span><span class="p">()</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="p">}</span></div>


<div class="viewcode-block" id="canonicalize_tautomer_smiles"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.canonicalize_tautomer_smiles">[docs]</a><span class="k">def</span> <span class="nf">canonicalize_tautomer_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a standardized canonical tautomer SMILES string given a SMILES string.</span>

<span class="sd">    Note: This is a convenience function for quickly standardizing and finding the canonical tautomer for a single</span>
<span class="sd">    SMILES string. It is more efficient to use the :class:`~molvs.standardize.Standardizer` class directly when working</span>
<span class="sd">    with many molecules or when custom options are needed.</span>

<span class="sd">    :param string smiles: The SMILES for the molecule.</span>
<span class="sd">    :returns: The SMILES for the standardize canonical tautomer.</span>
<span class="sd">    :rtype: string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Skip sanitize as standardize does this anyway</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Standardizer</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">tautomer</span> <span class="o">=</span> <span class="n">TautomerCanonicalizer</span><span class="p">()</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">tautomer</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#from .errors import StopValidateError</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="MolVSError"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.MolVSError">[docs]</a><span class="k">class</span> <span class="nc">MolVSError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="StandardizeError"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.StandardizeError">[docs]</a><span class="k">class</span> <span class="nc">StandardizeError</span><span class="p">(</span><span class="n">MolVSError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ValidateError"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.ValidateError">[docs]</a><span class="k">class</span> <span class="nc">ValidateError</span><span class="p">(</span><span class="n">MolVSError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="StopValidateError"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.StopValidateError">[docs]</a><span class="k">class</span> <span class="nc">StopValidateError</span><span class="p">(</span><span class="n">ValidateError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called by Validations to stop any further validations from being performed.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1"># from .validations import VALIDATIONS</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="Validation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Validation">[docs]</a><span class="k">class</span> <span class="nc">Validation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base class that all :class:`~molvs.validations.Validation` subclasses must inherit from.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;validation&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">StopValidateError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Validation failed: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<div class="viewcode-block" id="Validation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Validation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Validation subclasses must implement the run method&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SmartsValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.SmartsValidation">[docs]</a><span class="k">class</span> <span class="nc">SmartsValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract superclass for :class:`Validations &lt;molvs.validations.Validation&gt;` that log a message if a SMARTS</span>
<span class="sd">    pattern matches the molecule.</span>

<span class="sd">    Subclasses can override the following attributes:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: The logging level of the message.</span>
    <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span>

    <span class="c1">#: The message to log if the SMARTS pattern matches the molecule.</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Molecule matched </span><span class="si">%(smarts)s</span><span class="s1">&#39;</span>

    <span class="c1">#: Whether the SMARTS pattern should match an entire covalent unit.</span>
    <span class="n">entire_fragment</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SmartsValidation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smarts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smarts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The SMARTS pattern as a string. Subclasses must implement this.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;SmartsValidation subclasses must have a smarts attribute&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_smarts</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;smarts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">smarts</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_check_matches_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_smarts</span><span class="p">))</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">matches</span> <span class="o">&amp;</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;smarts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">smarts</span><span class="p">})</span>

<div class="viewcode-block" id="SmartsValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.SmartsValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entire_fragment</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_matches_fragment</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_matches</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IsNoneValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.IsNoneValidation">[docs]</a><span class="k">class</span> <span class="nc">IsNoneValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs an error if ``None`` is passed to the Validator.</span>

<span class="sd">    This can happen if RDKit failed to parse an input format. If the molecule is ``None``, no subsequent validations</span>
<span class="sd">    will run.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IsNoneValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.IsNoneValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Molecule is None&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">StopValidateError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="NoAtomValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.NoAtomValidation">[docs]</a><span class="k">class</span> <span class="nc">NoAtomValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs an error if the molecule has zero atoms.</span>

<span class="sd">    If the molecule has no atoms, no subsequent validations will run.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NoAtomValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.NoAtomValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No atoms are present&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">StopValidateError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="DichloroethaneValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.DichloroethaneValidation">[docs]</a><span class="k">class</span> <span class="nc">DichloroethaneValidation</span><span class="p">(</span><span class="n">SmartsValidation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs if 1,2-dichloroethane is present.</span>

<span class="sd">    This is provided as an example of how to subclass :class:`~molvs.validations.SmartsValidation` to check for the</span>
<span class="sd">    presence of a substructure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span>
    <span class="n">smarts</span> <span class="o">=</span> <span class="s1">&#39;[Cl]-[#6]-[#6]-[Cl]&#39;</span>
    <span class="n">entire_fragment</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;1,2-Dichloroethane is present&#39;</span></div>


<div class="viewcode-block" id="FragmentValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.FragmentValidation">[docs]</a><span class="k">class</span> <span class="nc">FragmentValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs if certain fragments are present.</span>

<span class="sd">    Subclass and override the ``fragments`` class attribute to customize the list of</span>
<span class="sd">    :class:`FragmentPatterns &lt;molvs.fragment.FragmentPattern&gt;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: A list of :class:`FragmentPatterns &lt;molvs.fragment.FragmentPattern&gt;` to check for.</span>
    <span class="n">fragments</span> <span class="o">=</span> <span class="n">REMOVE_FRAGMENTS</span>

<div class="viewcode-block" id="FragmentValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.FragmentValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">smarts</span><span class="p">))</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">matches</span> <span class="o">&amp;</span> <span class="n">fragments</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is present&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NeutralValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.NeutralValidation">[docs]</a><span class="k">class</span> <span class="nc">NeutralValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs if not an overall neutral system.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NeutralValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.NeutralValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chargestring</span> <span class="o">=</span> <span class="s1">&#39;+</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">charge</span> <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">charge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Not an overall neutral system (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">chargestring</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IsotopeValidation"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.IsotopeValidation">[docs]</a><span class="k">class</span> <span class="nc">IsotopeValidation</span><span class="p">(</span><span class="n">Validation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logs if molecule contains isotopes.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IsotopeValidation.run"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.IsotopeValidation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="n">isotopes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">isotope</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIsotope</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isotope</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isotopes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isotope</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">isotope</span> <span class="ow">in</span> <span class="n">isotopes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Molecule contains isotope </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">isotope</span><span class="p">)</span></div></div>


<span class="c1">#: The default list of :class:`Validations &lt;molvs.validations.Validation&gt;` used by :class:`~molvs.validate.Validator`.</span>
<span class="n">VALIDATIONS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">IsNoneValidation</span><span class="p">,</span>
    <span class="n">NoAtomValidation</span><span class="p">,</span>
    <span class="c1">#DichloroethaneValidation,</span>
    <span class="n">FragmentValidation</span><span class="p">,</span>
    <span class="n">NeutralValidation</span><span class="p">,</span>
    <span class="n">IsotopeValidation</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1">#: The default format for log messages.</span>
<span class="n">SIMPLE_FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(levelname)s</span><span class="s1">: [</span><span class="si">%(validation)s</span><span class="s1">] </span><span class="si">%(message)s</span><span class="s1">&#39;</span>

<span class="c1">#: A more detailed format for log messages. Specify when initializing a Validator.</span>
<span class="n">LONG_FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(validation)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span>


<div class="viewcode-block" id="LogHandler"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LogHandler">[docs]</a><span class="k">class</span> <span class="nc">LogHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Handler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A simple logging Handler that just stores logs in an array until flushed.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">Handler</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logmessages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">]</span>

<div class="viewcode-block" id="LogHandler.emit"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LogHandler.emit">[docs]</a>    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the record.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span></div>

<div class="viewcode-block" id="LogHandler.flush"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LogHandler.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the log records.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span></div>

<div class="viewcode-block" id="LogHandler.close"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.LogHandler.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the handler.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">Handler</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Validator"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Validator">[docs]</a><span class="k">class</span> <span class="nc">Validator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The main class for running :class:`Validations &lt;molvs.validations.Validation&gt;` on molecules.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validations</span><span class="o">=</span><span class="n">VALIDATIONS</span><span class="p">,</span> <span class="n">log_format</span><span class="o">=</span><span class="n">SIMPLE_FORMAT</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Validator with the following parameters:</span>

<span class="sd">        :param validations: A list of Validations to apply (default: :data:`~molvs.validations.VALIDATIONS`).</span>
<span class="sd">        :param string log_format: A string format (default: :data:`~molvs.validate.SIMPLE_FORMAT`).</span>
<span class="sd">        :param level: The minimum logging level to output.</span>
<span class="sd">        :param bool stdout: Whether to send log messages to standard output.</span>
<span class="sd">        :param bool raw: Whether to return raw :class:`~logging.LogRecord` objects instead of formatted log strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="c1"># Set up logger and add default LogHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">LogHandler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="n">log_format</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
        <span class="c1"># Add stdout StreamHandler if specified in parameters</span>
        <span class="k">if</span> <span class="n">stdout</span><span class="p">:</span>
            <span class="n">strhdlr</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="n">strhdlr</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="n">log_format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">strhdlr</span><span class="p">)</span>
        <span class="c1"># Instantiate the validations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validations</span> <span class="o">=</span> <span class="p">[</span><span class="n">validation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">)</span> <span class="k">for</span> <span class="n">validation</span> <span class="ow">in</span> <span class="n">validations</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling a Validator instance like a function is the same as calling its</span>
<span class="sd">        :meth:`~molvs.validate.Validator.validate` method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Validator.validate"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.Validator.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="c1"># Clear any log messages from previous runs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="c1"># Run every validation, stopping if StopValidateError is raised</span>
        <span class="k">for</span> <span class="n">validation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">validations</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validation</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">StopValidateError</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">logs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">logmessages</span></div></div>


<div class="viewcode-block" id="validate_smiles"><a class="viewcode-back" href="../../../modules/scopy.pretreat.html#scopy.pretreat.pretreatutil.validate_smiles">[docs]</a><span class="k">def</span> <span class="nf">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return log messages for a given SMILES string using the default validations.</span>

<span class="sd">    Note: This is a convenience function for quickly validating a single SMILES string. It is more efficient to use</span>
<span class="sd">    the :class:`~molvs.validate.Validator` class directly when working with many molecules or when custom options</span>
<span class="sd">    are needed.</span>

<span class="sd">    :param string smiles: The SMILES for the molecule.</span>
<span class="sd">    :returns: A list of log messages.</span>
<span class="sd">    :rtype: list of strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Skip sanitize as standardize does this anyway</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="n">Validator</span><span class="p">()</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logs</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;[Na]OC(=O)c1ccc(C[S+2]([O-])([O-]))cc1&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AddHs</span>
    
    <span class="n">mol</span> <span class="o">=</span> <span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Standardizer</span><span class="p">()</span>
    <span class="n">smol</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">standardize_smiles</span><span class="p">(</span><span class="s1">&#39;[Na]OC(=O)c1ccc(C[S+2]([O-])([O-]))cc1&#39;</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">LargestFragmentChooser</span><span class="p">()</span>
    <span class="n">lmol</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">lmol</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span> <span class="p">(</span><span class="n">standardize_smiles</span><span class="p">(</span><span class="s1">&#39;C[n+]1c([N-](C))cccc1&#39;</span><span class="p">))</span>











</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Scopy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Zhijiang Yang.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.0.
    </div>
  </body>
</html>